<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mz</title>
  <meta name="author" content="Mz">
  
  <meta name="description" content="MVVM的数据绑定 在这个前端大爆发的年头，追着这些框架跑，真的好无力。angular、vue、react三个框架在领跑着，angular要出2.0了，vue也要2.0了，各种框架蓄势待发，好像潮流又要改一改的节奏。。。 在这个对新手不友好的前端发展阶段，掌握一些核心才是关键。。。好的，我在扯淡，这">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Mz"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Mz" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Mz</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-08-28T11:26:10.439Z"><a href="/2016/08/28/5/">2016-08-28</a></time>
      
      
  
    <h1 class="title"></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="MVVM的数据绑定"><a href="#MVVM的数据绑定" class="headerlink" title="MVVM的数据绑定"></a>MVVM的数据绑定</h2><p> 在这个前端大爆发的年头，追着这些框架跑，真的好无力。angular、vue、react三个框架在领跑着，angular要出2.0了，vue也要2.0了，各种框架蓄势待发，好像潮流又要改一改的节奏。。。<br> 在这个对新手不友好的前端发展阶段，掌握一些核心才是关键。。。好的，我在扯淡，这是本人对mvvm的数据绑定的一些见解，请轻拍    </p>
<h4 id="angular1-x的检脏机制"><a href="#angular1-x的检脏机制" class="headerlink" title="angular1.x的检脏机制"></a>angular1.x的检脏机制</h4><p>先来看一些简单的例子</p>
<pre><code>&lt;body&gt;
&lt;span ng-bind = &quot;count&quot;&gt;&lt;/span&gt;
&lt;button ng-click = &quot;add&quot;&gt;+&lt;/button&gt;
&lt;button ng-click = &quot;minus&quot;&gt;-&lt;/button&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var Scope = function(){
    var scope = this
    //绑定指令的函数
    var bind = function(){
        var click = document.querySelectorAll(&apos;[ng-click]&apos;)
        click.forEach(function(item){
            console.log(item.getAttribute(&apos;ng-click&apos;))
            item.onclick = (function(item){
                return function(){
                    scope[item.getAttribute(&apos;ng-click&apos;)]()
                    scope.$apply()
                }
            })(item)
        })
    }
    bind()
    //检脏函数
    scope.$apply = function () {
        var span = document.querySelectorAll(&apos;[ng-bind]&apos;)
        span.forEach(function(item){
            if (item.innerHTML!==scope[item.getAttribute(&apos;ng-bind&apos;)]) {
                item.innerHTML = scope[item.getAttribute(&apos;ng-bind&apos;)]
            }
        })
    }
    //加法
    scope.add = function () {
        scope.count++ 
    }
    //减法
    scope.minus = function () {
        scope.count-- 
    }
    //绑定的数
    scope.count = 0
    //初始化
    scope.$apply()
}
Scope()
&lt;/script&gt;
&lt;/body&gt;
</code></pre><p>以上就是简单的实现<br>利用bind函数来将ng-click这个指令分装，在为点击事件绑定相应的方法然后调用apply进行脏检测，而apply方法检测视图的值与js变量值是否一致，不一致则对其进行视图值进行刷新。基本的实现就完成了。<br>在Scope函数的最后加上一个settimeout函数试试</p>
<pre><code>scope.$apply() //原有的
//添加settimeout方法
setTimeout(function(){
    scope.count++
    console.log(scope.count)//1
},1000)
</code></pre><p>显然上面代码是不行的，虽然值改变了（控制台输出1）,但是页面值没有改变，为什么这样呢？嗯，是没有去检脏导致的，所以我们需要手动得去检脏</p>
<pre><code>scope.$apply() //原有的
//添加settimeout方法
setTimeout(function(){
    scope.count++
    console.log(scope.count)//1
    scope.$apply()
},1000)
</code></pre><p>嗯，一切按我们所预想的实现了，页面值也在延时后变化了，这就是angular1.x的检脏机制。<br>原则上就是当变量改变了，就要去调用一次apply，来进行检脏。angular也为此封装了很多指令和服务，为我们自动检脏，例如ng-click，$timeout等<br>现在试着编写一个双向数据绑定的例子</p>
<pre><code>&lt;body&gt;
&lt;span ng-bind = &quot;count&quot;&gt;&lt;/span&gt;
&lt;button ng-click = &quot;add&quot;&gt;+&lt;/button&gt;
&lt;button ng-click = &quot;minus&quot;&gt;-&lt;/button&gt;
&lt;input ng-model = &quot;count&quot;/&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var Scope = function(){
    var scope = this
    //绑定指令的函数
    var bind = function(){
        var click = document.querySelectorAll(&apos;[ng-click]&apos;)
        click.forEach(function(item){
            console.log(item.getAttribute(&apos;ng-click&apos;))
            item.onclick = (function(item){
                return function(){
                    scope[item.getAttribute(&apos;ng-click&apos;)]()
                    scope.$apply()
                }
            })(item)
        })
        var input = document.querySelectorAll(&apos;[ng-model]&apos;)
        input.forEach(function(item){
            item.onkeyup = function(){
                scope[item.getAttribute(&apos;ng-model&apos;)] = item.value
                scope.$apply()
            }
            item.select = function(){
                scope[item.getAttribute(&apos;ng-model&apos;)] = item.value
                scope.$apply()
            }
        })
    }
    bind()
    //检脏函数
    scope.$apply = function () {
        var span = document.querySelectorAll(&apos;[ng-bind]&apos;)
        var input = document.querySelectorAll(&apos;[ng-model]&apos;)
        span.forEach(function(item){
            if (item.innerHTML!==scope[item.getAttribute(&apos;ng-bind&apos;)]) {
                item.innerHTML = scope[item.getAttribute(&apos;ng-bind&apos;)]
            }
        })
        input.forEach(function(item){
            if (item.value!==scope[item.getAttribute(&apos;ng-model&apos;)]) {
                item.value = scope[item.getAttribute(&apos;ng-model&apos;)]
            }
        })
    }
    //加法
    scope.add = function () {
        scope.count++ 
    }
    //减法
    scope.minus = function () {
        scope.count-- 
    }
    //绑定的数
    scope.count = 0
    //初始化
    scope.$apply()
    setTimeout(function(){
        scope.count++
        scope.$apply()
        console.log(scope.count)
    },1000)
}
Scope()
&lt;/script&gt;
&lt;/body&gt;
</code></pre><p>完美实现，这就是简单的双向数据绑定，利用input绑定事件来改变js的值，然后在检脏。<br>其实angular1.x里面的主要实现不一定和本文相符，它的双向绑定的事件也不是本文这样简单的keyup，select;<br>它主要是通过$compile来编译文本，把那些指令都给缓存起来，  这个模板引擎也会被编译成指令，而缓存的对象有视图值，变量值等属性，十分复杂，本文仅仅简单实现一下原理。。。</p>
<h4 id="vue的劫持get和set的方法"><a href="#vue的劫持get和set的方法" class="headerlink" title="vue的劫持get和set的方法"></a>vue的劫持get和set的方法</h4><p>先来说说Object.defineProperty<br>Object.defineProperty是ES5的一个特性，这也是为什么vue不支持IE8以下的理由。<br>Object.defineProperty(object, propertyname, descriptor)<br>object<br>必需。  要在其上添加或修改属性的对象。  这可能是一个本机 JavaScript 对象（即用户定义的对象或内置对象）或 DOM 对象。<br>propertyname<br>必需。  一个包含属性名称的字符串。<br>descriptor<br>必需。  属性描述符。  它可以针对数据属性或访问器属性。<br>来个栗子</p>
<pre><code>var test = { key:0 };
Object.defineProperty(test, &apos;key&apos;, {
    get: function() {
        console.log(&apos;get：&apos; + key);
        //do something
        return key;
    },
    set: function(value) {
        key = value;
        console.log(&apos;set:&apos; + key);
        //do something
    }
});
test.key = 2; // set:2
console.log(test.key); // get：2
</code></pre><p>从上面可以看出这个，每次访问或者操作一个对象的内容时都可以触发相应的回调函数（set,get）,这样实时监测对对象的操作，然后在do something执行设置好的监听函数之类的，进行数据的刷新。这样和检脏对比来说，性能可就好了很多，修改一个值，就刷新这个值所绑定的视图，而脏检测就只能遍历所有的新旧值。。。    但这仅限于对象，那在数组里面是怎样的呢，vue是直接把数组的原型给改了,对几个方法进行了封装。<br>请看下面这个栗子     </p>
<pre><code>Array.prototype.push_old = Array.prototype.push
delete Array.prototype[&apos;push&apos;]
Array.prototype.push = function  (data) {
    this.push_old(data)
    console.log(&apos;do somthing&apos;)
}
var arr = []
arr.push(2);  //do something
console.log(arr)  //[2]
arr.push([3])  //do something
console.log(arr)  //[2,[3]]
arr[1].push(3)  //do something
console.log(arr)  //[2,[3,3]]
</code></pre><p>这样就简单地把它封装好了，每次push之后，都可以执行相关的函数，把相应的视图进行刷新，很赞。但是vue可能并不是这么简单的玩起来。。下面是在别人blog抄来的一个vue源码节选</p>
<pre><code>const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)
/**
 - Intercept mutating methods and emit events
 */
;[
  &apos;push&apos;,
  &apos;pop&apos;,
  &apos;shift&apos;,
  &apos;unshift&apos;,
  &apos;splice&apos;,
  &apos;sort&apos;,
  &apos;reverse&apos;
]
.forEach(function (method) {
  // cache original method
  var original = arrayProto[method]
  def(arrayMethods, method, function mutator () {
    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    var i = arguments.length
    var args = new Array(i)
    while (i--) {
      args[i] = arguments[i]
    }
    var result = original.apply(this, args)
    var ob = this.__ob__
    var inserted
    switch (method) {
      case &apos;push&apos;:
        inserted = args
        break
      case &apos;unshift&apos;:
        inserted = args
        break
      case &apos;splice&apos;:
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    ob.dep.notify()
    return result
  })
})
</code></pre><p>vue把数组的几个方法改掉，用来可以触发监听的视图改变事件。但是这样子，还有一个问题，就是数组arr[1] = 0；这样的操作vue根本没办法检测到这样的操作发生。。为此 Vue.js 在文档中明确提示不建议直接角标修改数据，但也还是提供了一个$set方法来解决这个问题；其本质就是Array原型设置一个$set方法，类似angular的apply检脏；而且需要手动触发，也就是如果写了arr[1] = 0；然后又想要视图改变的话，手动执行$set方法。。  </p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>前端真的很有趣。。。</p>

      
    </div>
    <footer>
      
        
        
        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Kommentare</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://yoursite.com/2016/08/28/5/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Suche">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 Mz
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
